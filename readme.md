Услуги хостинга можно купить на определенный период: как на один месяц, так и на несколько лет. По истечению данного периода хостинг можно продлить, при этом число продлений не ограничено. В свою очередь, непродленная услуга блокируется и удаляется (происходит "отток услуги").

Нам интересно научиться определять какие услуги будут продлены по окончании периода использования, а какие услуги не продлятся и будут удалены. Это поможет понять причины оттока или заранее помочь клиентам решить их проблемы по данным услугам.

Для определения "непродления" или оттока услуги нужно построить модель прогнозирования оттока (услуг), которая сводится к бинарной классификации.
Кроме этого нам интересно понять, насколько хорошо модель описывает реальную картину мира. Для этого нужно будет оценить построенную модель на части услуг, которые должны не участвовать в построении модели (т.н. отложенная выборка).

## Задача

1) Простроить модель прогнозирования оттока услуг (`churn`)

2) Выбрать метрику и оценить качество модели на отложенной выборке

#### Замечания

- выбор метрики для оценки качества - свободный, 
- хочется увидеть не "самый лучший скор", а обоснование/доказательство, что данная модель *достаточно* хороша
- использование таблицы test - только для оценки модели, в процессе обучения не используется

**Приветствуется (необязательно)**

- Описательный анализ
- Интерпретируемость модели
- Обоснование выбора метрики для оценки качества модели
- Предложения по расчету возможного экономического эффекта

## Описание данных

Входные данные представлены в виде истории заказов услуг нашего хостинга.

1. Конкретная услуга (`service_id`) предоставляется для конкретного клиента (`user_id`) на определенный период. Вначале заказывается новая услуга, затем она продлевается (номер продления — `nth_renewal`, если 0 — то это первоначальный заказ).
2. По завершению периода *непродленная* услуга приостанавливается.
3. Каждая услуга может быть *продлена* (в любое время до истечения 60 дней после приостановки услуги).
4. В случае *продления* фиксируется заказ той же услуги на новый период (при этом `nth_renewal` инкрементируется).

Каждая запись соответствует конкретному периоду (`nth_renewal`) предоставления конкретной услуги (`service_id`) для конкретного клиента (`user_id`). 

#### Описание таблицы history

- user_id - id клиента
- service_ids - id услуги
- nth_renewal - номер продления данной услуги (0, если услуга - новая)
- pay_date - дата заказа/продления услуги
- start_date - начало периода услуги (услуга становится активной)
- expiration_date - исетечение периода услуги (услуга приостановлена)
- amount - длина периода активности в месяцах (на сколько месяцев услугу заказали/продлили)
- on_date - дата прогноза (за 14 дней до истечения услуги)
- churn - целевой признак: отток услуги на текущем периоде (услуга завершилась в этом периоде и не будет продляться, известна только для обучающей выборки)

#### Описание таблицы users

- user_id - id клиента
- regdate - дата регистрации клиента

#### Описание таблицы test (отложенная выборка)

- user_id - id клиента
- service_ids - id услуги
- nth_renewal - номер продления данной услуги (0, если услуга - новая)
- churn - целевой признак: отток услуги на текущем периоде (используется только для оценки, не для обучения)

#### Замечания

- у каждого клиента может быть более одной услуги
- каждая услуга заказывается на определенный период с start_date по expiration_date
- в момент прогноза (on_date) услуга уже может быть продлена (но только в обучающем наборе)
- отложенная выборка представлена в таблице test и хранит истинные значения целевого признака (`churn`)
- в таблице history присутствуют записи из отложенной выборки, чтобы упростить генерацию признаков на основе истории ...
- ... при этом целевой признак (`churn`) для отложенной выборки выставлен в NULL, чтобы избежать случайного использования при обучении 

#### Помощь

Чтобы сэкономить время на этапах чтения и предобработки данных, предлагаем ознакомиться с примером (1) выделения признаков и (2) получения обучающей выборки на языке Python в файле train_test_split.py.